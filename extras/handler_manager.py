# handlers/manager.py

from typing import Optional, Tuple

# Import the handler classes that will be managed by this manager.
# These imports assume the 'extras' directory is at the same level as 'handlers'.
from extras.think_parser import ThinkingAnimationHandler
from extras.file_content_handler import FileContentHandler
from extras.thinking_log_manager import ThinkingLogManager # Used for initializing handlers


class HandlerManager:
    """
    Manages the pipeline of token processing handlers (e.g., thinking, file generation).
    It orchestrates the flow of tokens through different handlers and consolidates their
    outputs into a unified return format for the main program.
    """

    def __init__(self,
                 log_manager: ThinkingLogManager,
                 output_base_dir: str,
                 thinking_mode: str = "progressbar",
                 enable_thinking_display: bool = True):
        """
        Initializes the HandlerManager and its internal token handlers.

        Args:
            log_manager (ThinkingLogManager): An instance of ThinkingLogManager for logging.
            output_base_dir (str): The base directory where files generated by the LLM
                                    should be saved.
            thinking_mode (str): The mode for the thinking animation (e.g., "progressbar").
            enable_thinking_display (bool): Whether to display thinking animations to the user.
        """
        # Initialize internal handlers. These handlers retain their original
        # initialization parameters and method signatures.
        self.thinking_handler: ThinkingAnimationHandler = ThinkingAnimationHandler(
            enable_display=enable_thinking_display,
            mode=thinking_mode,
            log_manager=log_manager,
        )

        self.file_content_handler: FileContentHandler = FileContentHandler(
            log_manager=log_manager,
            output_base_dir=output_base_dir,
        )

        # In the future, if new handlers are added that also need to be part of the
        # core token processing chain, they would be initialized here.
        # Example: self.tool_call_handler = ToolCallHandler(...)


    def process_token_chain(self, initial_token: str) -> Tuple[bool, str, Optional[str]]:
        """
        Processes a single token through the sequence of registered handlers.
        This method adapts to the existing interfaces of the individual handlers.

        The order of processing is crucial:
        1. ThinkingAnimationHandler: Determines if the LLM is 'thinking' and suppresses
           output to the user if so.
        2. FileContentHandler: Checks for file write commands and captures content for files.

        Args:
            initial_token (str): The token as received from the OutputPrinter.

        Returns:
            Tuple[bool, str, Optional[str]]:
            - display_to_user (bool): True if the token (or processed version) should be
                                      displayed to the user; False if a handler consumed it.
            - final_content_for_display (str): The actual content to be displayed to the user.
                                               Empty string if display_to_user is False.
            - file_content_saved (Optional[str]): If a file was just completed and saved,
                                                   its content is returned here. Otherwise, None.
        """
        # Flag to track if any handler has decided to suppress displaying this token
        should_display_this_token: bool = True
        # Content that flows down the pipeline from one handler to the next
        content_to_pass_down_pipeline: str = initial_token
        # Variable to capture any 'special output' like a completed file content
        bubbled_file_content: Optional[str] = None

        # --- Stage 1: Process with ThinkingAnimationHandler ---
        # Calls the specific method of ThinkingAnimationHandler.
        # This handler decides if the token is part of a 'thought' process.
        is_thinking, content_from_thinking_handler = \
            self.thinking_handler.process_token_and_thinking_state(initial_token)

        if is_thinking:
            # If the LLM is actively thinking, we suppress the token from being displayed
            # to the user, but the thought content still flows to the next handler
            # (e.g., if a file command is embedded within a thought).
            should_display_this_token = False
            content_to_pass_down_pipeline = content_from_thinking_handler
        else:
            # If not thinking, the content from this handler (which might be the
            # original token or a filtered version) is passed down.
            content_to_pass_down_pipeline = content_from_thinking_handler

        # --- Stage 2: Process with FileContentHandler ---
        # Calls the specific method of FileContentHandler.
        # This handler looks for file write commands.
        is_file_active, content_from_file_handler, file_data_just_saved = \
            self.file_content_handler.process_token(content_to_pass_down_pipeline)

        if is_file_active:
            # If the LLM is actively writing to a file, this content should not
            # be displayed to the user.
            should_display_this_token = False
            # 'content_from_file_handler' here is the content being accumulated for the file,
            # not for display. It doesn't need to be passed further down for display purposes.

        if file_data_just_saved is not None:
            # If a file was just completed and saved by the FileContentHandler,
            # capture its content to bubble it up to the main program.
            bubbled_file_content = file_data_just_saved

        # --- Final Determination for Display ---
        final_content_for_display: str
        if should_display_this_token:
            # If no handler in the pipeline decided to suppress the display,
            # the content produced by the last handler (FileContentHandler)
            # is what should be presented to the user.
            final_content_for_display = content_from_file_handler
        else:
            # If any handler suppressed the display, the final content for display is empty.
            final_content_for_display = ""

        # Return the consolidated results: whether to display, what content to display,
        # and any special data (like completed file content).
        return should_display_this_token, final_content_for_display, bubbled_file_content

